import { z } from "zod";
import { IContext, IMemoryManager, IContextManager, ToolCallResult, ToolCallParams, ToolCallDefinition, IRAGEnabledContext } from "../interfaces";
import { render } from "../utils";
import { ToolCallDefinitionSchema, ToolCallParamsSchema, ToolCallResultSchema } from "../interfaces";
import { ContextHelper } from "../utils";
import { logger } from "../utils/logger";

const SimpleToolCallDefSchema = ToolCallDefinitionSchema.pick({
    name: true,
    description: true,
    async: true
});
export type SimpleToolCallDef = z.infer<typeof SimpleToolCallDefSchema>;

// 新的工具调用数据结构，合并了调用和结果
const ToolCallContextDataSchema = z.object({
    toolCalls: z.array(z.object({
        call_id: z.string(),
        name: z.string(),
        async: z.boolean(),
        status: z.enum(["pending", "completed"]),
        parameters: z.any().optional().describe("Tool call parameters"),
        result: z.any().optional().describe("Tool execution result - success/failure determined by result content")
    }))
}).describe("Unified tool call tracking with parameters and results in a single structure");

export type ToolCallContextData = z.infer<typeof ToolCallContextDataSchema>;

// 辅助函数：判断工具调用是否成功
export function isToolCallSuccessful(toolCall: z.infer<typeof ToolCallContextDataSchema>['toolCalls'][0]): boolean {
    if (toolCall.status !== 'completed' || !toolCall.result) {
        return false;
    }
    
    // 检查标准化的 success 字段
    if (typeof toolCall.result === 'object' && 'success' in toolCall.result) {
        return Boolean(toolCall.result.success);
    }
    
    // 向后兼容：如果没有 success 字段但有 error 字段，则认为失败
    if (typeof toolCall.result === 'object' && 'error' in toolCall.result) {
        return false;
    }
    
    // 默认认为成功（向后兼容旧格式）
    return true;
}

// 辅助函数：获取工具调用的错误信息
export function getToolCallError(toolCall: z.infer<typeof ToolCallContextDataSchema>['toolCalls'][0]): string | null {
    if (toolCall.status !== 'completed' || !toolCall.result) {
        return null;
    }
    
    // 检查标准化的 error 字段
    if (typeof toolCall.result === 'object' && 'error' in toolCall.result && toolCall.result.error) {
        return String(toolCall.result.error);
    }
    
    return null;
}

// 保留旧的类型定义以便向后兼容（如果需要）
const ToolAsyncCallContextDataSchema = z.object({
    toolDefinitions: z.array(SimpleToolCallDefSchema).describe("the tool defition list. ToolDefinitiondefine the tool name,desctiption,input param and the output result"),
    toolCalls: z.array(ToolCallParamsSchema),
    toolResults: z.array(ToolCallResultSchema)
}).describe("toolDefinitions define all the function, toolCalls is generated by the LLM and give the input param and the which tool handler should be called, toolResults record the tool handler result after exection.");
export type ToolAsyncCallContextData = z.infer<typeof ToolAsyncCallContextDataSchema>;


export const ToolCallContextId = "tool-call-context";
export const ToolCallContext = Object.assign(
    ContextHelper.createRAGContext({
        id: ToolCallContextId,
        description: "Tracks all tool call requests and their results.",
        dataSchema: ToolCallContextDataSchema,
        initialData: {
            toolCalls: []
        },
        renderPromptFn: (data: z.infer<typeof ToolCallContextDataSchema>) => {
            const pendingCalls = data.toolCalls.filter(tc => tc.status === 'pending');
            const completedCalls = data.toolCalls.filter(tc => tc.status === 'completed');
            
            // 从已完成的调用中区分成功和失败
            const successfulCalls = completedCalls.filter(isToolCallSuccessful);
            const failedCalls = completedCalls.filter(tc => !isToolCallSuccessful(tc));
            
            const toolContextPrompt = `
            IMPORTANT TOOL EXECUTION RULES:
            *   Sync Tools (\`async: false\`): These execute IMMEDIATELY. The agent waits for them. Use these for critical, blocking actions.
            *   Async Tools (\`async: true\`): These are queued and run in the BACKGROUND. The agent DOES NOT wait. Their results will appear LATER, potentially after several steps. Use these for non-blocking, long-running tasks.
            
            Guidance:
            *   Check \`toolCalls\` using \`call_id\` and \`status\` to see the status of previous calls.
            *   Do NOT repeatedly call a tool if its corresponding \`call_id\` is already in \`toolCalls\` with status 'pending' or 'completed', especially for async tools.
            *   Pay attention to the \`async\` flag when deciding which tool to use.
            *   For completed calls, check the \`result\` field to determine success/failure.

            Current Tool Call Status:
            Total Calls: {{totalCalls}}
            Pending: {{pendingCount}} ({{pendingCalls}})
            Completed: {{completedCount}} (Successful: {{successfulCount}}, Failed: {{failedCount}})
            
            All Tool Calls: {{allToolCalls}}
            `;
            return render(toolContextPrompt, {
                totalCalls: data.toolCalls.length,
                pendingCount: pendingCalls.length,
                pendingCalls: JSON.stringify(pendingCalls.map(tc => ({ call_id: tc.call_id, name: tc.name, async: tc.async })), null, 2),
                completedCount: completedCalls.length,
                successfulCount: successfulCalls.length,
                failedCount: failedCalls.length,
                allToolCalls: JSON.stringify(data.toolCalls, null, 2)
            });
        },
    }),
    {
        // 新的 setToolCalls 方法：创建工具调用记录，初始状态为 pending，result 为空
        setToolCalls(this: IRAGEnabledContext<typeof ToolCallContextDataSchema>, toolCalls: ToolCallParams[]): void {
            const data = this.data as z.infer<typeof ToolCallContextDataSchema>;
            
            // 为每个工具调用创建新的记录
            const newToolCalls = toolCalls.map(tc => ({
                call_id: tc.call_id,
                name: tc.name,
                async: false, // 默认为同步，会在 agent 中根据实际工具设置
                status: 'pending' as const,
                parameters: tc.parameters,
                result: undefined
            }));
            
            // 添加到现有的工具调用列表中（不覆盖）
            data.toolCalls.push(...newToolCalls);
            
            logger.debug(`Added ${newToolCalls.length} new tool calls to context`);
        },
        
        // 新的 setToolCallResult 方法：更新工具调用的结果和状态
        setToolCallResult(this: IRAGEnabledContext<typeof ToolCallContextDataSchema>, toolCallId: string, result: ToolCallResult): void {
            const data = this.data as z.infer<typeof ToolCallContextDataSchema>;
            const toolCallIndex = data.toolCalls.findIndex(tc => tc.call_id === toolCallId);
            
            if (toolCallIndex === -1) {
                throw new Error(`Tool call ${toolCallId} not found`);
            }
            
            const toolCall = data.toolCalls[toolCallIndex];
            
            // 检查是否已经有结果
            if (toolCall.status === 'completed') {
                logger.warn(`Tool call ${toolCallId} already has a result, skipping update`);
                return;
            }
            
            // 更新工具调用的结果和状态（无论成功失败都标记为 completed）
            data.toolCalls[toolCallIndex] = {
                ...toolCall,
                status: 'completed',
                result: result.result
            };
            
            logger.debug(`Updated tool call ${toolCallId} with result, status: ${data.toolCalls[toolCallIndex].status}`);
        },
        
        // 新增方法：更新工具调用的 async 标志
        updateToolCallAsync(this: IRAGEnabledContext<typeof ToolCallContextDataSchema>, toolCallId: string, isAsync: boolean): void {
            const data = this.data as z.infer<typeof ToolCallContextDataSchema>;
            const toolCallIndex = data.toolCalls.findIndex(tc => tc.call_id === toolCallId);
            
            if (toolCallIndex === -1) {
                logger.warn(`Tool call ${toolCallId} not found for async update`);
                return;
            }
            
            data.toolCalls[toolCallIndex].async = isAsync;
            logger.debug(`Updated tool call ${toolCallId} async flag to: ${isAsync}`);
        }
    }
);

