import { z } from "zod";
import { IContext, IMemoryManager, IContextManager, ToolCallResult, ToolCallParams, ToolCallDefinition, IRAGEnabledContext } from "../interfaces";
import { render } from "../utils";
import { ToolCallDefinitionSchema, ToolCallParamsSchema, ToolCallResultSchema } from "../interfaces";
import { ContextHelper } from "../utils";
import { logger } from "../utils/logger";

const SimpleToolCallDefSchema = ToolCallDefinitionSchema.pick({
    name: true,
    description: true,
    async: true
});
export type SimpleToolCallDef = z.infer<typeof SimpleToolCallDefSchema>;

const ToolAsyncCallContextDataSchema = z.object({
    toolDefinitions: z.array(SimpleToolCallDefSchema).describe("the tool defition list. ToolDefinitiondefine the tool name,desctiption,input param and the output result"),
    toolCalls: z.array(ToolCallParamsSchema),
    toolResults: z.array(ToolCallResultSchema)
}).describe("toolDefinitions define all the function, toolCalls is generated by the LLM and give the input param and the which tool handler should be called, toolResults record the tool handler result after exection.");
export type ToolAsyncCallContextData = z.infer<typeof ToolAsyncCallContextDataSchema>;

export const ToolCallContextId = "tool-call-context";
export const ToolCallContext = Object.assign(
    ContextHelper.createRAGContext({
        id: ToolCallContextId,
        description: "Tracks all tool call requests and their results. Used to coordinate which tools the agent can call, their async/sync status, and to correlate tool calls with their results. Essential for managing tool execution flow and preventing duplicate or conflicting tool invocations.",
        dataSchema: ToolAsyncCallContextDataSchema,
        initialData: {
            toolDefinitions: [],
            toolCalls: [],
            toolResults: []
        },
        renderPromptFn: (data: z.infer<typeof ToolAsyncCallContextDataSchema>) => {
            const toolContextPrompt = `
            ------ ToolCallContext (Tracks Tool Calls & Results) ------
            1.  \`toolDefinitions\`: Lists available tools. Each tool has an \`async\` flag (true/false). 
            2.  \`toolCalls\`: Records tools the LLM decided to call in the last step (identified by \`call_id\`).
            3.  \`toolResults\`: Contains results for completed tool calls (correlated by \`call_id\`).
            
            IMPORTANT TOOL EXECUTION RULES:
            *   Sync Tools (\`async: false\`): These execute IMMEDIATELY. The agent waits for them. Their results will appear quickly in \`toolResults\`. Examples: \`stop-response\`, \`response-cli\`. Use these for critical, blocking actions.
            *   Async Tools (\`async: true\`): These are queued and run in the BACKGROUND. The agent DOES NOT wait. Their results will appear in \`toolResults\` LATER, potentially after several steps. Use these for non-blocking, long-running tasks.
            
            Guidance:
            *   Check \`toolCalls\` and \`toolResults\` using \`call_id\` to see the status of previous calls.
            *   Do NOT repeatedly call a tool if its corresponding \`call_id\` is already in \`toolCalls\` and awaiting a result in \`toolResults\`, especially for async tools.
            *   Pay attention to the \`async\` flag in \`toolDefinitions\` when deciding which tool to use.

            Current Tool State:
            ToolDefinitions: {{toolDefinitions}}
            ToolCalls: {{toolCalls}}
            ToolResults: {{toolResults}}
            `;
            return render(toolContextPrompt, {
                toolDefinitions: JSON.stringify(data.toolDefinitions, null, 2),
                toolCalls: JSON.stringify(data.toolCalls, null, 2),
                toolResults: JSON.stringify(data.toolResults, null, 2)
            });
        },
    }),
    {
        setToolDefinitions(this: IRAGEnabledContext<typeof ToolAsyncCallContextDataSchema>, toolDefinitions: ToolCallDefinition[]): void {
            try {
                const simpleToolDefs = toolDefinitions.map((tool) => {
                    return SimpleToolCallDefSchema.parse(tool);
                });
                
                logger.debug(`Converting ${toolDefinitions.length} tool definitions to SimpleToolCallDef format`);
                (this.data as z.infer<typeof ToolAsyncCallContextDataSchema>).toolDefinitions = simpleToolDefs;
            } catch (error) {
                logger.error("Error converting tool definitions to SimpleToolCallDef format:", error);
                throw error;
            }
        },
        
        setToolCalls(this: IRAGEnabledContext<typeof ToolAsyncCallContextDataSchema>, toolCalls: ToolCallParams[]): void {
            (this.data as z.infer<typeof ToolAsyncCallContextDataSchema>).toolCalls = toolCalls;
        },
        
        setToolCallResult(this: IRAGEnabledContext<typeof ToolAsyncCallContextDataSchema>, toolCallId: string, result: ToolCallResult): void {
            const data = this.data as z.infer<typeof ToolAsyncCallContextDataSchema>;
            const toolCall = data.toolCalls.find((tc: ToolCallParams) => tc.call_id === toolCallId);
            if (!toolCall) {
                throw new Error(`Tool call ${toolCallId} not found`);
            }
            
            const resultExist = data.toolResults.find((tr: ToolCallResult) => tr.call_id === toolCallId);
            if (resultExist) {
                throw new Error(`Tool call result ${toolCallId} already set`);
            }
            data.toolResults.push(result);
        }
    }
);

