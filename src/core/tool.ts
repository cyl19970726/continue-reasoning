import { z } from "zod";
import { IContext, IMemoryManager, IContextManager, ToolCallResult, ToolCallParams, ToolCallDefinition } from "./interfaces";
import { render } from "./utils";
import { ToolCallDefinitionSchema, ToolCallParamsSchema, ToolCallResultSchema } from "./interfaces";
import { createContext } from "./utils";

const ToolAsyncCallContextDataSchema = z.object({
    toolDefinitions: z.array(ToolCallDefinitionSchema).describe("the tool defition list. ToolDefinitiondefine the tool name,desctiption,input param and the output result"),
    toolCalls: z.array(ToolCallParamsSchema),
    toolResults: z.array(ToolCallResultSchema)
}).describe("toolDefinitions define all the function, toolCalls is generated by the LLM and give the input param and the which tool handler should be called, toolResults record the tool handler result after exection.");
export type ToolAsyncCallContextData = z.infer<typeof ToolAsyncCallContextDataSchema>;

// 添加工具调用内存 Schema
const ToolMemorySchema = z.object({
    toolDefinitions: z.array(ToolCallDefinitionSchema),
    toolCalls: z.array(ToolCallParamsSchema),
    toolResults: z.array(ToolCallResultSchema),
    timestamp: z.date(),
    metadata: z.record(z.unknown()).optional()
});

export const ToolCallContextId = "tool-call-context";
export const ToolCallContext = Object.assign(
    createContext({
        id: ToolCallContextId,
        description: "ToolCallContext stores the context for tool calls and results",
        dataSchema: ToolAsyncCallContextDataSchema,
        memorySchema: ToolMemorySchema,
        initialData: {
            toolDefinitions: [],
            toolCalls: [],
            toolResults: []
        },
        renderPromptFn: (data: z.infer<typeof ToolAsyncCallContextDataSchema>) => {
            const toolContextPrompt = `
            ------ ToolCallContext (Tracks Tool Calls & Results) ------
            1.  \`toolDefinitions\`: Lists available tools. Each tool has an \`async\` flag (true/false). 
            2.  \`toolCalls\`: Records tools the LLM decided to call in the last step (identified by \`call_id\`).
            3.  \`toolResults\`: Contains results for completed tool calls (correlated by \`call_id\`).
            
            IMPORTANT TOOL EXECUTION RULES:
            *   Sync Tools (\`async: false\`): These execute IMMEDIATELY. The agent waits for them. Their results will appear quickly in \`toolResults\`. Examples: \`stop-response\`, \`response-cli\`. Use these for critical, blocking actions.
            *   Async Tools (\`async: true\`): These are queued and run in the BACKGROUND. The agent DOES NOT wait. Their results will appear in \`toolResults\` LATER, potentially after several steps. Use these for non-blocking, long-running tasks.
            
            Guidance:
            *   Check \`toolCalls\` and \`toolResults\` using \`call_id\` to see the status of previous calls.
            *   Do NOT repeatedly call a tool if its corresponding \`call_id\` is already in \`toolCalls\` and awaiting a result in \`toolResults\`, especially for async tools.
            *   Pay attention to the \`async\` flag in \`toolDefinitions\` when deciding which tool to use.

            Current Tool State:
            {{data}}
            `;
            return render(toolContextPrompt, {
                data: JSON.stringify(data, null, 2)
            });
        },
        toolListFn: () => []
    }),
    {
        setToolDefinitions(this: IContext<typeof ToolAsyncCallContextDataSchema, typeof ToolMemorySchema>, toolDefinitions: ToolCallDefinition[]): void {
            (this.data as z.infer<typeof ToolAsyncCallContextDataSchema>).toolDefinitions = toolDefinitions;
        },
        
        setToolCalls(this: IContext<typeof ToolAsyncCallContextDataSchema, typeof ToolMemorySchema>, toolCalls: ToolCallParams[]): void {
            (this.data as z.infer<typeof ToolAsyncCallContextDataSchema>).toolCalls = toolCalls;
        },
        
        setToolCallResult(this: IContext<typeof ToolAsyncCallContextDataSchema, typeof ToolMemorySchema>, toolCallId: string, result: ToolCallResult): void {
            const data = this.data as z.infer<typeof ToolAsyncCallContextDataSchema>;
            const toolCall = data.toolCalls.find((tc: ToolCallParams) => tc.call_id === toolCallId);
            if (!toolCall) {
                throw new Error(`Tool call ${toolCallId} not found`);
            }
            
            const resultExist = data.toolResults.find((tr: ToolCallResult) => tr.call_id === toolCallId);
            if (resultExist) {
                throw new Error(`Tool call result ${toolCallId} already set`);
            }
            data.toolResults.push(result);
        }
    }
);

