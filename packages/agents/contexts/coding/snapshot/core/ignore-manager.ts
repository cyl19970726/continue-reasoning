/**
 * Ignore Manager - Handles snapshot ignore rules and file filtering
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { SnapshotConfig } from '../interfaces.js';

interface IgnoreRules {
  patterns: string[];
  isIgnored: (filePath: string) => boolean;
}

export class IgnoreManager {
  private workspacePath: string;
  private snapshotIgnorePath: string;
  private config: SnapshotConfig;
  private ignoreRules?: IgnoreRules;

  constructor(workspacePath: string, config: SnapshotConfig) {
    this.workspacePath = workspacePath;
    this.snapshotIgnorePath = path.join(workspacePath, '.snapshotignore');
    this.config = config;
  }

  /**
   * Initialize ignore manager
   */
  async initialize(): Promise<void> {
    // Check if .snapshotignore file exists, create it if not
    try {
      await fs.access(this.snapshotIgnorePath);
    } catch (error) {
      // File doesn't exist, create default one
      await this.createDefaultSnapshotIgnore();
    }
    
    await this.loadIgnoreRules();
  }

  /**
   * Load ignore rules from .snapshotignore file
   */
  async loadIgnoreRules(): Promise<void> {
    try {
      const ignoreContent = await fs.readFile(this.snapshotIgnorePath, 'utf-8');
      const patterns = ignoreContent
        .split('\n')
        .map(line => {
          // Handle inline comments: split on # symbol, keep only the part before comment
          const commentIndex = line.indexOf('#');
          const cleanLine = commentIndex >= 0 ? line.substring(0, commentIndex) : line;
          return cleanLine.trim();
        })
        .filter(line => line); // Filter out empty lines

      this.ignoreRules = {
        patterns,
        isIgnored: (filePath: string) => this.isFileIgnored(filePath, patterns)
      };
    } catch (error) {
      // Ignore file doesn't exist or failed to read, use default rules
      this.ignoreRules = {
        patterns: this.getDefaultIgnorePatterns(),
        isIgnored: (filePath: string) => this.isFileIgnored(filePath, this.getDefaultIgnorePatterns())
      };
    }
  }

  /**
   * Filter out ignored files from a list
   */
  filterIgnoredFiles(filePaths: string[]): string[] {
    if (!this.ignoreRules) {
      return filePaths;
    }
    
    return filePaths.filter(filePath => !this.ignoreRules!.isIgnored(filePath));
  }

  /**
   * Check if a single file is ignored
   */
  isIgnored(filePath: string): boolean {
    return this.ignoreRules ? this.ignoreRules.isIgnored(filePath) : false;
  }

  /**
   * Create default .snapshotignore file
   */
  async createDefaultSnapshotIgnore(): Promise<void> {
    const defaultContent = `# .snapshotignore - Configure files and directories to ignore in snapshot system
# Syntax similar to .gitignore, supports glob pattern matching

# ===== Snapshot system files =====
.continue-reasoning/**
.snapshotignore         # Ignore .snapshotignore file itself

# ===== Temporary files and system files =====
*.log
*.tmp
.DS_Store
Thumbs.db

# ===== Build artifacts and dependencies =====
node_modules/**
dist/**
build/**
__pycache__/**
*.pyc
*.pyo

# ===== IDE and editor files =====
.vscode/**
.idea/**
*.swp
*.swo
*~

# ===== Runtime generated data files =====
# These files are usually generated by program execution and should not be tracked by snapshot system
*.json                  # Can be adjusted to more specific rules as needed
*.csv
*.xlsx
*_output.*
*_result.*
*_data.*

# ===== Cache files =====
.cache/**
*.cache

# ===== Version control systems =====
.git/**
.svn/**

# ===== Custom rules =====
# Add project-specific ignore rules here
# For example:
# my_project_outputs/**
# *.generated
`;

    try {
      await fs.writeFile(this.snapshotIgnorePath, defaultContent, 'utf-8');
      console.log(`üìù Created default .snapshotignore file at: ${this.snapshotIgnorePath}`);
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Failed to create .snapshotignore file: ${error}`);
    }
  }

  /**
   * Get current ignore information
   */
  getIgnoreInfo(): {
    ignoreFilePath: string;
    ignoreFileExists: boolean;
    patterns: string[];
    isLoaded: boolean;
  } {
    return {
      ignoreFilePath: this.snapshotIgnorePath,
      ignoreFileExists: require('fs').existsSync(this.snapshotIgnorePath),
      patterns: this.ignoreRules?.patterns || [],
      isLoaded: !!this.ignoreRules
    };
  }

  /**
   * Reload ignore rules
   */
  async reloadIgnoreRules(): Promise<void> {
    await this.loadIgnoreRules();
    console.log(`üìù Reloaded ignore rules. Active patterns: ${this.ignoreRules?.patterns.length || 0}`);
  }

  // Private helper methods

  private getDefaultIgnorePatterns(): string[] {
    // Combine default patterns with configuration exclusions
    const defaultPatterns = [
      // Snapshot system's own files
      '.continue-reasoning/**',
      '.snapshotignore',  // Ignore .snapshotignore file itself
      
      // Common temporary files and logs
      '*.log',
      '*.tmp',
      '.DS_Store',
      'Thumbs.db',
      
      // Build artifacts
      'node_modules/**',
      'dist/**',
      'build/**',
      '__pycache__/**',
      '*.pyc',
      '*.pyo',
      
      // IDE and editor files
      '.vscode/**',
      '.idea/**',
      '*.swp',
      '*.swo',
      '*~',
      
      // Runtime generated data files (key to solving current issues)
      '*.json',  // Can be adjusted to more specific rules like '*_output.json', '*_result.json' etc.
      '*.csv',
      '*.xlsx',
      
      // Cache files
      '.cache/**',
      '*.cache',
      
      // Version control
      '.git/**',
      '.svn/**'
    ];
    
    return [...defaultPatterns, ...this.config.excludeFromChecking];
  }

  private isFileIgnored(filePath: string, patterns: string[]): boolean {
    // Convert absolute path to relative path from workspace
    const relativePath = path.isAbsolute(filePath) 
      ? path.relative(this.workspacePath, filePath)
      : filePath;
    
    // Normalize path separators
    const normalizedPath = relativePath.replace(/\\/g, '/');
    
    for (const pattern of patterns) {
      if (this.matchPattern(normalizedPath, pattern)) {
        return true;
      }
    }
    
    return false;
  }

  private matchPattern(filePath: string, pattern: string): boolean {
    // Fix: Process ** before single *, avoid replacement order issues
    let regexPattern = pattern
      .replace(/\./g, '\\.')     // Escape dots
      .replace(/\*\*/g, '###DOUBLESTAR###')  // Temporarily replace **
      .replace(/\*/g, '[^/]*')   // Process single *
      .replace(/###DOUBLESTAR###/g, '.*')    // Replace ** with .*
      .replace(/\?/g, '[^/]');   // ? matches single character
    
    // If pattern ends with /, it matches directories
    if (pattern.endsWith('/')) {
      regexPattern += '.*';
    }
    
    // For patterns containing path separators, handle correctly
    if (pattern.includes('/')) {
      // If pattern starts with /, match from root directory
      if (pattern.startsWith('/')) {
        regexPattern = '^' + regexPattern.substring(1) + '$';
      } else {
        // Otherwise match from beginning
        regexPattern = '^' + regexPattern + '$';
      }
    } else {
      // For patterns without path separators, can match filename
      regexPattern = '(^|/)' + regexPattern + '($|/)';  
    }
    
    const regex = new RegExp(regexPattern);
    return regex.test(filePath);
  }
} 