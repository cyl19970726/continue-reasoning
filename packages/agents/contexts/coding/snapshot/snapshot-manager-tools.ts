/**
 * Snapshot Manager Tools - Based on new modular SnapshotManager
 * 
 * Provides core snapshot management tools:
 * - ReadSnapshotTool: Read snapshot details
 * - ListSnapshotsTool: View snapshot history
 * - MergeSnapshotTool: Storage optimization (merge snapshots)
 * - RevertSnapshotTool: Rollback snapshots
 */

import { createTool, IAgent } from '@continue-reasoning/core';
import { z } from 'zod';
import { SnapshotManager } from './snapshot-manager';
import { IRuntime } from '../runtime/interface';

// Helper function to get workspace path from agent
function getWorkspacePath(agent?: IAgent): string {
  const codingContext = agent?.contextManager.findContextById('coding-context');
  if (codingContext) {
    const data = (codingContext as any).getData();
    if (data?.current_workspace) {
      return data.current_workspace;
    }
  }
  return process.cwd();
}

// Helper function to get runtime from agent
function getRuntime(agent?: IAgent): IRuntime | null {
  const codingContext = agent?.contextManager.findContextById('coding-context');
  if (codingContext) {
    return (codingContext as any).getRuntime() as IRuntime;
  }
  return null;
}

// Input schemas
const ReadSnapshotInputSchema = z.object({
  snapshotId: z.string().describe('Snapshot ID'),
  includeDiff: z.boolean().optional().describe('Whether to include diff content, default is true'),
  returnDiffPath: z.boolean().optional().describe('Whether to return diff file path instead of content, default is false')
});

const ListSnapshotsInputSchema = z.object({
  limit: z.number().optional().describe('Limit of returned snapshots'),
  since: z.string().optional().describe('Start time (ISO string)'),
  until: z.string().optional().describe('End time (ISO string)'),
  toolFilter: z.array(z.string()).optional().describe('Filter by tool type'),
  fileFilter: z.string().optional().describe('Filter by file name'),
  includeDiffs: z.boolean().optional().describe('Whether to include diff content, default is false')
});

const MergeSnapshotInputSchema = z.object({
  // Either specify exact snapshot IDs or use sequence number range (mutually exclusive)
  snapshotIds: z.array(z.string()).optional().describe('List of specific snapshot IDs to merge (mutually exclusive with sequenceNumberRange)'),
  sequenceNumberRange: z.object({
    start: z.number().describe('Starting sequence number (inclusive)'),
    end: z.number().describe('Ending sequence number (inclusive)')
  }).optional().describe('Range of sequence numbers to merge (mutually exclusive with snapshotIds)'),
  
  title: z.string().describe('Title of the merged snapshot'),
  goal: z.string().describe('Goal/purpose of merging these snapshots')
});

const RevertSnapshotInputSchema = z.object({
  snapshotId: z.string().describe('Snapshot ID to revert'),
  dryRun: z.boolean().optional().describe('Whether to preview only, not execute, default is false'),
  force: z.boolean().optional().describe('Whether to force execution, ignoring conflict checks, default is false')
});

// Output schemas
const SnapshotDetailSchema = z.object({
  id: z.string(),
  timestamp: z.string(),
  description: z.string(),
  tool: z.string(),
  affectedFiles: z.array(z.string()),
  sequenceNumber: z.number(),
  previousSnapshotId: z.string().optional(),
  diff: z.string().optional(),
  diffPath: z.string().optional(),
  reverseDiffPath: z.string().optional(),
  metadata: z.object({
    filesSizeBytes: z.number(),
    linesChanged: z.number(),
    executionTimeMs: z.number()
  })
});

const ReadSnapshotOutputSchema = z.object({
  success: z.boolean(),
  snapshot: SnapshotDetailSchema.optional(),
  error: z.string().optional()
});

const ListSnapshotsOutputSchema = z.object({
  success: z.boolean(),
  snapshots: z.array(SnapshotDetailSchema),
  pagination: z.object({
    total: z.number(),
    hasMore: z.boolean(),
    nextCursor: z.string().optional()
  }),
  error: z.string().optional()
});

const MergeSnapshotOutputSchema = z.object({
  success: z.boolean(),
  mergedSnapshotId: z.string().optional(),
  diffPath: z.string().optional(),
  originalSnapshotIds: z.array(z.string()),
  spaceFreed: z.number(),
  message: z.string()
});

const RevertSnapshotOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  reversedDiff: z.string().optional(),
  affectedFiles: z.array(z.string()).optional(),
  conflicts: z.array(z.string()).optional(),
  newSnapshotId: z.string().optional(),
  diffPath: z.string().optional()
});

/**
 * ReadSnapshotTool - Read snapshot details
 */
export const ReadSnapshotTool = createTool({
  id: 'ReadSnapshot',
  name: 'ReadSnapshot',
  description: 'Read detailed information of specified snapshot which generated by Apply* tools, including metadata, affected files and optional diff content',
  inputSchema: ReadSnapshotInputSchema,
  outputSchema: ReadSnapshotOutputSchema,
  async: true,
  execute: async (params, agent?: IAgent) => {
    try {
      const workspacePath = getWorkspacePath(agent);
      const snapshotManager = new SnapshotManager(workspacePath);
      
      await snapshotManager.initialize();
      
      // Read snapshot
      const result = await snapshotManager.readSnapshotDiff(params.snapshotId);
      
      if (!result.success || !result.snapshot) {
        return {
          success: false,
          error: `Snapshot ${params.snapshotId} not found`
        };
      }

      if (params.includeDiff === undefined) {
        params.includeDiff = true;
      }
      if (params.returnDiffPath === undefined) {
        params.returnDiffPath = false;
      }
      
      // Build return data
      const snapshotDetail = {
        id: result.snapshot.id,
        timestamp: result.snapshot.timestamp,
        description: result.snapshot.description,
        tool: result.snapshot.tool,
        affectedFiles: result.snapshot.affectedFiles,
        sequenceNumber: result.snapshot.sequenceNumber,
        previousSnapshotId: result.snapshot.previousSnapshotId,
        diff: params.includeDiff && !params.returnDiffPath ? result.diff : undefined,
        diffPath: params.returnDiffPath ? result.snapshot.diffPath : undefined,
        reverseDiffPath: params.returnDiffPath ? result.snapshot.reverseDiffPath : undefined,
        metadata: {
          filesSizeBytes: result.snapshot.metadata?.filesSizeBytes || 0,
          linesChanged: result.snapshot.metadata?.linesChanged || 0,
          executionTimeMs: result.snapshot.metadata?.executionTimeMs || 0
        }
      };
      
      return {
        success: true,
        snapshot: snapshotDetail
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to read snapshot: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
});

/**
 * ListSnapshotsTool - View snapshot history
 */
export const ListSnapshotsTool = createTool({
  id: 'ListSnapshots',
  name: 'ListSnapshots',
  description: 'Get snapshot history list with support for various filtering conditions and pagination',
  inputSchema: ListSnapshotsInputSchema,
  outputSchema: ListSnapshotsOutputSchema,
  async: true,
  execute: async (params, agent?: IAgent) => {
    if (params.includeDiffs === undefined) {
      params.includeDiffs = false;
    }
    if (params.limit === undefined) {
      params.limit = 20;
    }

    try {
      const workspacePath = getWorkspacePath(agent);
      const snapshotManager = new SnapshotManager(workspacePath);
      
      await snapshotManager.initialize();
      
      // Get edit history
      const historyResult = await snapshotManager.getEditHistory({
        limit: params.limit,
        since: params.since,
        until: params.until,
        toolFilter: params.toolFilter,
        fileFilter: params.fileFilter,
        includeDiffs: params.includeDiffs
      });
      
      // Convert to output format - get sequenceNumber and previousSnapshotId from readSnapshotDiff
      const snapshots = [];
      for (const item of historyResult.history) {
        // Use readSnapshotDiff to get complete snapshot data including diffPath
        const completeSnapshot = await snapshotManager.readSnapshotDiff(item.id);
        if (completeSnapshot.success && completeSnapshot.snapshot) {
          snapshots.push({
            id: item.id,
            timestamp: item.timestamp,
            description: item.description,
            tool: item.tool,
            affectedFiles: item.affectedFiles,
            sequenceNumber: completeSnapshot.snapshot.sequenceNumber,
            previousSnapshotId: completeSnapshot.snapshot.previousSnapshotId,
            diff: item.diff,
            diffPath: completeSnapshot.snapshot.diffPath,
            reverseDiffPath: completeSnapshot.snapshot.reverseDiffPath,
            metadata: {
              filesSizeBytes: completeSnapshot.snapshot.metadata?.filesSizeBytes || 0,
              linesChanged: item.metadata.linesChanged,
              executionTimeMs: item.metadata.executionTimeMs
            }
          });
        }
      }
      
      return {
        success: true,
        snapshots,
        pagination: historyResult.pagination
      };
    } catch (error) {
      return {
        success: false,
        snapshots: [],
        pagination: { total: 0, hasMore: false },
        error: `Failed to get snapshot list: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
});

/**
 * MergeSnapshotTool - Storage optimization (merge snapshots)
 */
export const MergeSnapshotTool = createTool({
  id: 'MergeSnapshot',
  name: 'MergeSnapshot',
  description: 'Merge multiple consecutive snapshots into a single consolidated snapshot for advanced workflow organization and storage optimization. CRITICAL FEATURES: 1) Combines multiple snapshots into one optimized snapshot with combined diff; 2) Automatically renumbers subsequent snapshots to maintain sequence continuity (e.g., merge snapshots 1,2 â†’ remaining snapshots 3,4,5 become 2,3,4); 3) Always deletes original snapshots after successful merge; 4) Reduces prompt token usage and improves execution efficiency; 5) Essential for organizing development phases into logical units. Use after completing development phases to keep snapshot history clean and organized.',
  inputSchema: MergeSnapshotInputSchema,
  outputSchema: MergeSnapshotOutputSchema,
  async: true,
  execute: async (params, agent?: IAgent) => {
    try {
      const workspacePath = getWorkspacePath(agent);
      const snapshotManager = new SnapshotManager(workspacePath);
      
      await snapshotManager.initialize();
      
      // Validate input: exactly one of snapshotIds or sequenceNumberRange must be provided
      const hasSnapshotIds = params.snapshotIds && params.snapshotIds.length > 0;
      const hasSequenceRange = params.sequenceNumberRange;
      
      if (!hasSnapshotIds && !hasSequenceRange) {
        return {
          success: false,
          originalSnapshotIds: [],
          spaceFreed: 0,
          message: 'Must provide either snapshotIds or sequenceNumberRange'
        };
      }
      
      if (hasSnapshotIds && hasSequenceRange) {
        return {
          success: false,
          originalSnapshotIds: params.snapshotIds || [],
          spaceFreed: 0,
          message: 'Cannot provide both snapshotIds and sequenceNumberRange'
        };
      }
      
      let snapshotIds: string[];
      
        if (hasSequenceRange) {
         // Use the new bottom-level method to get snapshot IDs by sequence range
         snapshotIds = await snapshotManager.getSnapshotIdsBySequenceRange(
           params.sequenceNumberRange!.start,
           params.sequenceNumberRange!.end
         );
         
         if (snapshotIds.length === 0) {
           return {
             success: false,
             originalSnapshotIds: [],
             spaceFreed: 0,
             message: `No snapshots found in sequence range ${params.sequenceNumberRange!.start}-${params.sequenceNumberRange!.end}`
           };
         }
        } else {
         snapshotIds = params.snapshotIds!;
        }
      
      // Execute snapshot merge (always delete originals)
      const result = await snapshotManager.consolidateSnapshots({
        snapshotIds,
        title: params.title,
        description: params.goal,
        deleteOriginals: true
      });
      
      // Force cache reload after merge to ensure sequence numbers are up-to-date
      if (result.success) {
        await snapshotManager.initialize(); // This will reload the cache
      }
      
      // If successful, get the diffPath from the consolidated snapshot
      let diffPath: string | undefined;
      if (result.success && result.consolidatedSnapshotId) {
        const snapshotResult = await snapshotManager.readSnapshotDiff(result.consolidatedSnapshotId);
        if (snapshotResult.success && snapshotResult.snapshot) {
          diffPath = snapshotResult.snapshot.diffPath;
        }
      }
      
      return {
        success: result.success,
        mergedSnapshotId: result.consolidatedSnapshotId,
        diffPath,
        originalSnapshotIds: result.originalSnapshotIds,
        spaceFreed: result.spaceFreed,
        message: result.message || (result.success ? 'Merge successful' : 'Merge failed')
      };
    } catch (error) {
      const fallbackIds = params.snapshotIds || [];
      return {
        success: false,
        originalSnapshotIds: fallbackIds,
        spaceFreed: 0,
        message: `Snapshot merge failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
});

/**
 * RevertSnapshotTool - Rollback snapshot
 */
export const RevertSnapshotTool = createTool({
  id: 'RevertSnapshot',
  name: 'RevertSnapshot',
  description: 'Rollback the operation of specified snapshot, restoring files to the state before the snapshot',
  inputSchema: RevertSnapshotInputSchema,
  outputSchema: RevertSnapshotOutputSchema,
  async: true,
  execute: async (params, agent?: IAgent) => {
    if (params.dryRun === undefined) {
      params.dryRun = false;
    }
    if (params.force === undefined) {
      params.force = false;
    }
    
    try {
      const workspacePath = getWorkspacePath(agent);
      const runtime = getRuntime(agent);
      
      if (!runtime) {
        return {
          success: false,
          message: 'Missing runtime environment, cannot execute file operations'
        };
      }
      
      const snapshotManager = new SnapshotManager(workspacePath);
      await snapshotManager.initialize();
      
      // Execute rollback operation
      const result = await snapshotManager.reverseOp(params.snapshotId, {
        dryRun: params.dryRun,
        force: params.force
      }, runtime);
      
      // If successful and a new snapshot was created, get its diffPath
      let diffPath: string | undefined;
      if (result.success && result.newSnapshotId) {
        const snapshotResult = await snapshotManager.readSnapshotDiff(result.newSnapshotId);
        if (snapshotResult.success && snapshotResult.snapshot) {
          diffPath = snapshotResult.snapshot.diffPath;
        }
      }
      
      // Ensure message is always a string
      return {
        success: result.success,
        message: result.message || (result.success ? 'Rollback successful' : 'Rollback failed'),
        reversedDiff: result.reversedDiff,
        affectedFiles: result.affectedFiles,
        newSnapshotId: result.newSnapshotId,
        diffPath
      };
    } catch (error) {
      return {
        success: false,
        message: `Snapshot rollback failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
});

// Export all tools
export const snapshotManagerTools = [
  ReadSnapshotTool,
  ListSnapshotsTool,
  MergeSnapshotTool,
  RevertSnapshotTool
];


export default snapshotManagerTools; 